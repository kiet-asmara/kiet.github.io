[{"content":"Learning Go one step at a time.\n","date":"18 January 2024","permalink":"/tags/golang/","section":"Tags","summary":"Learning Go one step at a time.","title":"Golang"},{"content":"Error handling is one of the things I\u0026rsquo;ve struggled with the most while learning Go. The issue lies in where and how to handle these errors. It\u0026rsquo;s mostly agreed upon that it should be done separately from the main application, but there are many ways to do this and it\u0026rsquo;s hard to decide which one is the \u0026lsquo;best practice\u0026rsquo;. So I thought: why not make a compilation of them?\nNow, of course I know that it differs from project to project and there is no \u0026lsquo;best practice\u0026rsquo;. I just made this for fun üòÅ.\nLet\u0026rsquo;s start with the basics.\nDaisy-chaining # One of the first things I learned in Go, daisy-chaining errors is when errors are wrapped with the method or function that they are in. This is used to make debugging easier as errors show a clear trace when returned. I was really attracted to this idea due to my background of working with PLCs, and the whole concept of a daisy-chain was just neat.\nfunc thisFunction() error { err := someFunction() return fmt.Errorf(\u0026#34;this function: %w\u0026#34;, err) } func someFunction() error { _, err := stringToInt() return fmt.Errorf(\u0026#34;some function: %w\u0026#34;, err) } func stringToInt() (int, error) { number, err := strconv.Atoi(\u0026#34;five\u0026#34;) if err != nil { return 0, fmt.Errorf(\u0026#34;string to int: %w\u0026#34;, err) } return number, nil } func main() { err := thisFunction() if err != nil { fmt.Println(err) } } In this example the thisFunction calls someFunction, which calls another function stringToInt that returns an error by default. Each of these errors are followed by the name of the function below it.\nthis function: some function: string to int: strconv.Atoi: parsing \u0026#34;five\u0026#34;: invalid syntax This is extremely useful to detect errors that do not return the filename and line of where the error occurred (eg: app/cmd/main.go:23 main.function()) and in applications that have many layers. I found it very useful in my project clothera, a basic CLI app made with native Go.\nDaisy-chaining worked perfectly in that project because a CLI app didn\u0026rsquo;t need to send these errors to higher layer to be handled if it wasn\u0026rsquo;t needed. All you need to do was fmt.Println(err) at the same function and it appears in the terminal.\nThis is why I abandoned this way of error handling once I started building APIs. From seeing other people\u0026rsquo;s code, it was common practice to standardize errors by creating custom ones and handling these errors should ideally be centralized in one layer. In the top layer, asserting the type of error would be difficult. Also, tracing errors could be done through logging package using flags and whatnot.\nSo, daisy-chaining seemed a bit obsolete. If I really wanted to make it work, a lot of effort would be needed for little in return. I thought to just follow the common practice and spend my time learning other things. Maybe I\u0026rsquo;ll come back to this later in the future.\nCustom Errors # The next error handling method I learned was custom errors. It\u0026rsquo;s not exactly a method, but a standard. A separate file would be created to store these errors, also known as error contracts. These contracts would then be used to replace common, easily handled errors without needing to parse the error any further as there is already a defined global variable.\nimport \u0026#34;errors\u0026#34; var ( ErrBadRequest = errors.New(\u0026#34;bad request\u0026#34;) ErrInternalFailure = errors.New(\u0026#34;internal failure\u0026#34;) ErrNotFound = errors.New(\u0026#34;not found\u0026#34;) ErrFailedBind = errors.New(\u0026#34;failed bind json\u0026#34;) ErrUnauthorized = errors.New(\u0026#34;access unauthorized\u0026#34;) ) ... A basic implementation would include an array of custom errors created by errors.New(), which are then easily identfied using the errors.Is() and errors.As() functions. The errors are passed from the internals to the controllers to be handled in a specific way. For example, ErrFailedBind would indicate that the actual error needed to be parsed to display which of the input fields were invalid, whereas ErrUnauthorized would return the same message to the user everytime. Below is an example of parsing the ErrFailedBind.\nvar Validate *validator.Validate = validator.New() // handle binding errors func ErrorBind(err error) string { var ve validator.ValidationErrors out := \u0026#34;\u0026#34; if errors.As(err, \u0026amp;ve) { for _, fe := range ve { out = fe.Field() + \u0026#34;: \u0026#34; + msgForTag(fe.Tag()) } return out } return out } // error fields func msgForTag(tag string) string { switch tag { case \u0026#34;required\u0026#34;: return \u0026#34;This field is required\u0026#34; case \u0026#34;email\u0026#34;: return \u0026#34;Invalid email\u0026#34; case \u0026#34;alpha\u0026#34;: return \u0026#34;Must be alphabetical\u0026#34; case \u0026#34;gte\u0026#34;: return \u0026#34;Input too short\u0026#34; } return \u0026#34;\u0026#34; } A New Error Type # In my experience, a more convenient way of implementing this in an API is to create a whole new error type APIError that includes the HTTP status code along with the error message.\ntype APIError struct { Code int Message string } var ( ErrInternalServer = APIError{ Code: http.StatusInternalServerError, //500 Message: \u0026#34;Internal Server Error\u0026#34;, } ErrDataNotFound = APIError{ Code: http.StatusOK, //200 Message: \u0026#34;Data Not Found\u0026#34;, } ErrBadRequest = APIError{ Code: http.StatusBadRequest, //400 Message: \u0026#34;Bad request\u0026#34;, } ErrUnauthorized = APIError{ Code: http.StatusUnauthorized, //401 Message: \u0026#34;Request Unauthorized\u0026#34;, } ) These errors are used all over the handlers, where they are entered into a simple ErrorMessage function that logs and returns the error. One of my mentors provided this very simple template in Gin, which he used in his previous job (in a large company).\nimport \u0026#34;github.com/gin-gonic/gin\u0026#34; func ErrorMessage(c *gin.Context, apiError *APIError, err error) *gin.Context { log.Println(err) c.Abort() c.JSON(apiError.Code, gin.H{\u0026#34;error\u0026#34;: APIError{ Code: apiError.Code, Message: apiError.Message, }}) return c } An example handler:\nfunc AddProduct(c *gin.Context) { var product entity.Product err := c.BindJSON(\u0026amp;product) if err != nil { utils.ErrorMessage(c, \u0026amp;utils.ErrBadRequest, err) return } config.DB.Create(\u0026amp;product) c.JSON(200, product) } While this simple approach works well, the way it handles the application error (the actual error) is lacking. There needs to be another function added in some of the handlers which makes it a little messy.\nImplementing the error Interface # A way to expand on the new error type is to implement the error interface by giving the type an Error() method that returns a string of the error. By doing this, it allows you to do some type assertion with errors.As() and handle the app errors semi-gracefully.\ntype error interface { Error() string } In my Hotel 626 project, I used an error type that contains the generic http error and the actual application error, named service error (svcErr) and app error (appErr).\ntype Error struct { svcErr error // generic http error appErr error // actual error } func NewError(svcErr, appErr error) error { return Error{ svcErr: svcErr, appErr: appErr, } } // to be included in the error interface func (e Error) Error() string { return errors.Join(e.svcErr, e.appErr).Error() } In the service layer, the two errors would be wrapped in the Error struct using the NewError function and sent to the handlers above to be parsed. The new error is accepted as a normal error type which makes this convenient.\ntype APIError struct { Status int Message string } func FromError(err error) APIError { var svcError Error var apiError APIError // errors as checks if both are type utils.Error if errors.As(err, \u0026amp;svcError) { // set actual error on message apiError.Message = svcError.AppError().Error() // check error svcErr := svcError.ServiceError() switch svcErr { case ErrFailedBind: apiError.Message = ErrorBind(svcError.AppError()) // check which field fails validation apiError.Status = http.StatusBadRequest case ErrBadRequest: apiError.Status = http.StatusBadRequest case ErrInternalFailure: apiError.Status = http.StatusInternalServerError case ErrNotFound: apiError.Status = http.StatusNotFound case ErrUnauthorized: apiError.Status = http.StatusUnauthorized } } return apiError } In the handlers, the error is parsed by the FromError function which is at the core of this pattern. This function checks whether the received error contains the appErr and SvcErr field using errors.As. If it does, the error wil by casted to the APIError struct that displays the status code and message for the user. This message will be unique for certain errors such as ErrFailedBind which shows which input field is invalid. For other errors, the message will be kept uniform to prevent unwanted information leaks.\nIn cases where the error check fails (usually in a panic), the error is immediately caught by a middleware. In the project I used the one provided by Echo with a basic logger. See the full utils package for more details.\n// located in main e.Use(middleware.RecoverWithConfig(middleware.RecoverConfig{ StackSize: 1 \u0026lt;\u0026lt; 10, // 1 KB LogErrorFunc: utils.LogError, })) // in the utils package func LogError(c echo.Context, err error, stack []byte) error { log.Println(err) return echo.NewHTTPError(http.StatusInternalServerError, err) } This method of error handling is the one that feels the most comfortable to me, because new errors and methods can be easily added to the error contracts and the switch in the FromError function.\nHowever, there is a flaw in the fact that all these errors are located in the utils package/folder and every part of application that uses them are dependant on them, creating tight coupling between packages.\nThe Coupling Problem # In software engineering, coupling or dependency is the degree to which each program module relies on each one of the other modules. This means when a system A is tightly coupled with B, if A changes, B must also change. Tight coupling is usually an unwanted quality to have in an API, as APIs wants its components to be flexible, reusable, and adaptable.\nThe error package I described might not be suited for that since it uses type-assertion where the type of the error is checked. This means that the error types/contracts must be public, which creates a strong coupling with the caller, making for a brittle API. It also violates the Open-closed principle from the SOLID principles. This blog post by Dave Cheney explains these issues much better than I can.\nSo what\u0026rsquo;s the solution? Well, in the same post Cheney said that we should check errors by behaviour instead of type. In this case, the error package only needs to be in the top layer with the handlers. He provides some methods to do this, but I personally have never seen this being done in an actual application. It just seems to hard to implement in some cases.\nThe closest thing I\u0026rsquo;ve seen is not including the full error package in the service. In each service or domain, only the needed error contracts exist. For example, ErrUnauthorized only exists in the user domain.\nSo, should we check by behaviour or type? The answer probably lies in between. Use type when behaviour doesn\u0026rsquo;t work. Though, I\u0026rsquo;ve never really seen this strongly applied anywhere. I might be not advanced enough to see or understand more complex implementations.\nConclusion (I\u0026rsquo;m confused) # In the end, I am still confused on what \u0026lsquo;perfect\u0026rsquo; error handling looks like in Go. Do big companies have a more advanced system? Does it even exist?\nEither way, I think sticking to simple custom errors is enough for now.\nSources # https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully https://blog.dreamfactory.com/the-importance-of-loose-coupling-in-rest-api-design/ https://en.wikipedia.org/wiki/Coupling_(computer_programming) https://www.youtube.com/watch?v=CxcxRgwWtAk ","date":"18 January 2024","permalink":"/posts/custom-error-handling-in-go/","section":"Blog","summary":"Error handling is one of the things I\u0026rsquo;ve struggled with the most while learning Go. The issue lies in where and how to handle these errors. It\u0026rsquo;s mostly agreed upon that it should be done separately from the main application, but there are many ways to do this and it\u0026rsquo;s hard to decide which one is the \u0026lsquo;best practice\u0026rsquo;.","title":"How do you even handle errors in Go?"},{"content":"Hi üëã, I\u0026rsquo;m Kiet! This site is meant for me to document the things that I\u0026rsquo;ve learned. Mostly working with Golang.\n","date":"18 January 2024","permalink":"/","section":"Kiet's blog","summary":"Hi üëã, I\u0026rsquo;m Kiet! This site is meant for me to document the things that I\u0026rsquo;ve learned. Mostly working with Golang.","title":"Kiet's blog"},{"content":"Explore the blog by topic.\n","date":"18 January 2024","permalink":"/tags/","section":"Tags","summary":"Explore the blog by topic.","title":"Tags"},{"content":"Articles that I write in my spare time.\n","date":"13 June 2022","permalink":"/posts/","section":"Blog","summary":"Articles that I write in my spare time.","title":"Blog"},{"content":"Hi, I\u0026rsquo;m Kiet üëã # I\u0026rsquo;m an aspiring software engineer who works in the back-end. I recently graduated from the Sepuluh Nopember Institute of Technology with a bachelor\u0026rsquo;s degree in Electrical-Engineering (EE). However, I\u0026rsquo;ve decided to pursue a slightly different career path: software engineering.\nPersonally, working in EE; dealing with PLCs, Motors, electrical diagrams, and other technical work wasn\u0026rsquo;t as enjoyable as programming software. The feeling I get seeing my projects come to life (albeit in a screen) is very enjoyable to me.\nMaybe it\u0026rsquo;s the fact that software documentation is more readily available than in EE. I remember spending a whole week reading the manual book of an Omron synchronous motor, and still not understanding a single thing. Whereas with the GCP or Golang docs, it would take much less time to understand since I can look up what other people have said using Google.\nThat\u0026rsquo;s why I want to become a software engineer. Hopefully a good one üòÅ.\n","date":"1 January 0001","permalink":"/about/","section":"Kiet's blog","summary":"Hi, I\u0026rsquo;m Kiet üëã # I\u0026rsquo;m an aspiring software engineer who works in the back-end. I recently graduated from the Sepuluh Nopember Institute of Technology with a bachelor\u0026rsquo;s degree in Electrical-Engineering (EE).","title":"About Me"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"This section contains some of my projects and certificates. Other exercises/projects are located in my github.\nü•ù Kiwish # Kiwish is an e-commerce application with many features, made using microservices and gRPC. Notable features include payment gateway, shipment tracking, and e-mail notifications. The service was deployed on Google Cloud Run, while the databases are deployed on Railway. Created as the final project for the Hacktiv8 bootcamp program with two of my friends.\nRepo | API Documentation\nüîé True Sight # Tech Stack:\rGoogle Cloud Flask Kotlin Tensorflow True Sight is a news credibility checker platform that uses Natural Language Processing (NLP) to validate news submitted by users. App was available on Android using an API deployed on Google Cloud Run. I was in charge of designing the Google Cloud infrastructure. Created as the final project of the Bangkit Academy 2022 program with five other teammates.\nRepo | Slideshow\nüëî Clothera # Clothera is a simple CLI app for a Clothing store. Made purely with Golang and MySQL. Created for the Hacktiv8 bootcamp program with two of my friends.\nRepo | Slideshow\nüè¨ Hotel 626 # A hotel API mini-project made in around 24 hours. Created with Golang, PostgreSQL, GORM, and Echo. Includes a Xendit payment gateway and email notifications. Made for the Hacktiv8 bootcamp program.\nRepo\n‚öôÔ∏è DC Motor Speed Control with EKF \u0026amp; PI-PSO # A program to estimate and control the speed of a non-linear DC Motor without using speed sensors, only electrical sensors. The estimation was done using the Extended Kalman Filter (EKF) while the motor was controlled by a PI controller, tuned using the Particle Swarm Optimization (PSO) algorithm. The program was made using MATLAB scripts and Simulink. Created as my final project in university.\nRepo | Slideshow | Article\nüìú Certificates # ‚òÅÔ∏è Google Cloud Associate Cloud Engineer # An Associate Cloud Engineer deploys applications, monitors operations, and manages enterprise solutions. This individual is able to use Google Cloud Console and the command-line interface to perform common platform-based tasks to maintain one or more deployed solutions that leverage Google-managed or self-managed services on Google Cloud.\nLink: 5bce81b8cabf428aab3976f6247c4cb7\nüìö TOEFL iBT # The TOEFL iBT¬Æ test measures the ability to use and understand academic English. This certification is an asset for international mobility in over 160 countries. This test is a world reference. More than 35 million people worldwide have attested to their English language proficiency by taking the TOEFL iBT test. The test assesses written and oral comprehension and expression skills in an academic context from intermediate to advanced levels.\nFull certificate provided by request.\n","date":"1 January 0001","permalink":"/projects/","section":"Projects","summary":"This section contains some of my projects and certificates. Other exercises/projects are located in my github.\nü•ù Kiwish # Kiwish is an e-commerce application with many features, made using microservices and gRPC.","title":"Projects"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]