[{"content":"Learning Go one step at a time.\n","date":"18 January 2024","permalink":"/tags/golang/","section":"Tags","summary":"Learning Go one step at a time.","title":"Golang"},{"content":"Error handling is one of the things I\u0026rsquo;ve struggled with the most while learning Go. The issue lies in where and how to handle these errors. It\u0026rsquo;s mostly agreed upon that it should be done separately from the main application, but there are many ways to do this and it\u0026rsquo;s hard to decide which one is the \u0026lsquo;best practice\u0026rsquo;. So I thought: why not make a compilation of them?\nNow, of course I know that it differs from project to project and there is no \u0026lsquo;best practice\u0026rsquo;. I just made this for fun üòÅ.\nLet\u0026rsquo;s start with the basics.\nDaisy-chaining # One of the first things I learned in Go, daisy-chaining errors is when errors are wrapped with the method or function that they are in. This is used to make debugging easier as errors show a clear trace when returned. I was really attracted to this idea due to my background of working with PLCs, and the whole concept of a daisy-chain was just neat.\nfunc thisFunction() error { err := someFunction() return fmt.Errorf(\u0026#34;this function: %w\u0026#34;, err) } func someFunction() error { _, err := stringToInt() return fmt.Errorf(\u0026#34;some function: %w\u0026#34;, err) } func stringToInt() (int, error) { number, err := strconv.Atoi(\u0026#34;five\u0026#34;) if err != nil { return 0, fmt.Errorf(\u0026#34;string to int: %w\u0026#34;, err) } return number, nil } func main() { err := thisFunction() if err != nil { fmt.Println(err) } } In this example the thisFunction calls someFunction, which calls another function stringToInt that returns an error by default. Each of these errors are followed by the name of the function below it.\nthis function: some function: string to int: strconv.Atoi: parsing \u0026#34;five\u0026#34;: invalid syntax This is extremely useful to detect errors that do not return the filename and line of where the error occurred (eg: app/cmd/main.go:23 main.function()) and in applications that have many layers. I found it very useful in my project clothera, a basic CLI app made with native Go.\nDaisy-chaining worked perfectly in that project because a CLI app didn\u0026rsquo;t need to send these errors to higher layer to be handled if it wasn\u0026rsquo;t needed. All you need to do was fmt.Println(err) at the same function and it appears in the terminal.\nThis is why I abandoned this way of error handling once I started building APIs. From seeing other people\u0026rsquo;s code, it was common practice to standardize errors by creating custom ones and handling these errors should ideally be centralized in one layer. In the top layer, asserting the type of error would be difficult. Also, tracing errors could be done through logging package using flags and whatnot.\nSo, daisy-chaining seemed a bit obsolete. If I really wanted to make it work, a lot of effort would be needed for little in return. I thought to just follow the common practice and spend my time learning other things. Maybe I\u0026rsquo;ll come back to this later in the future.\nCustom Errors # The next error handling method I learned was custom errors. It\u0026rsquo;s not exactly a method, but a standard. A separate file would be created to store these errors, also known as error contracts. These contracts would then be used to replace common, easily handled errors without needing to parse the error any further as there is already a defined global variable.\nimport \u0026#34;errors\u0026#34; var ( ErrBadRequest = errors.New(\u0026#34;bad request\u0026#34;) ErrInternalFailure = errors.New(\u0026#34;internal failure\u0026#34;) ErrNotFound = errors.New(\u0026#34;not found\u0026#34;) ErrFailedBind = errors.New(\u0026#34;failed bind json\u0026#34;) ErrUnauthorized = errors.New(\u0026#34;access unauthorized\u0026#34;) ) ... A basic implementation would include an array of custom errors created by errors.New(), which are then easily identfied using the errors.Is() and errors.As() functions. The errors are passed from the internals to the controllers to be handled in a specific way. For example, ErrFailedBind would indicate that the actual error needed to be parsed to display which of the input fields were invalid, whereas ErrUnauthorized would return the same message to the user everytime. Below is an example of parsing the ErrFailedBind.\nvar Validate *validator.Validate = validator.New() // handle binding errors func ErrorBind(err error) string { var ve validator.ValidationErrors out := \u0026#34;\u0026#34; if errors.As(err, \u0026amp;ve) { for _, fe := range ve { out = fe.Field() + \u0026#34;: \u0026#34; + msgForTag(fe.Tag()) } return out } return out } // error fields func msgForTag(tag string) string { switch tag { case \u0026#34;required\u0026#34;: return \u0026#34;This field is required\u0026#34; case \u0026#34;email\u0026#34;: return \u0026#34;Invalid email\u0026#34; case \u0026#34;alpha\u0026#34;: return \u0026#34;Must be alphabetical\u0026#34; case \u0026#34;gte\u0026#34;: return \u0026#34;Input too short\u0026#34; } return \u0026#34;\u0026#34; } A New Type # In my experience, a more convenient way of implementing this in an API is to create a whole new type APIError that includes the HTTP status code along with the error message.\ntype APIError struct { Code int Message string } var ( ErrInternalServer = APIError{ Code: http.StatusInternalServerError, //500 Message: \u0026#34;Internal Server Error\u0026#34;, } ErrDataNotFound = APIError{ Code: http.StatusOK, //200 Message: \u0026#34;Data Not Found\u0026#34;, } ErrBadRequest = APIError{ Code: http.StatusBadRequest, //400 Message: \u0026#34;Bad request\u0026#34;, } ErrUnauthorized = APIError{ Code: http.StatusUnauthorized, //401 Message: \u0026#34;Request Unauthorized\u0026#34;, } ) These errors are used all over the handlers, where they are entered into a simple ErrorMessage function that logs and returns the error. One of my mentors provided this very simple template in Gin, which he used in his previous job (in a large company).\nimport \u0026#34;github.com/gin-gonic/gin\u0026#34; func ErrorMessage(c *gin.Context, apiError *APIError, err error) *gin.Context { log.Println(err) c.Abort() c.JSON(apiError.Code, gin.H{\u0026#34;error\u0026#34;: APIError{ Code: apiError.Code, Message: apiError.Message, }}) return c } An example handler:\nfunc AddProduct(c *gin.Context) { var product entity.Product err := c.BindJSON(\u0026amp;product) if err != nil { utils.ErrorMessage(c, \u0026amp;utils.ErrBadRequest, err) return } config.DB.Create(\u0026amp;product) c.JSON(200, product) } While this simple approach works well, the way it handles the application error (the actual error) is lacking. There needs to be another function added in some of the handlers which makes it a little messy.\nImplementing the error Interface # A way to expand on the new error type is to implement the error interface by giving the type an Error() method that returns a string of the error. By doing this, it allows you to do some type assertion with errors.As() and handle the app errors semi-gracefully.\ntype error interface { Error() string } The Coupling Problem # The Ideal # This blog post explains the issues\nThe Real # Conclusion (I\u0026rsquo;m confused) # ","date":"18 January 2024","permalink":"/posts/custom-error-handling-in-go/","section":"Blog","summary":"Error handling is one of the things I\u0026rsquo;ve struggled with the most while learning Go. The issue lies in where and how to handle these errors. It\u0026rsquo;s mostly agreed upon that it should be done separately from the main application, but there are many ways to do this and it\u0026rsquo;s hard to decide which one is the \u0026lsquo;best practice\u0026rsquo;.","title":"How do you even handle errors in Go?"},{"content":"Hi üëã, I\u0026rsquo;m Kiet! This site is meant for me to document the things that I\u0026rsquo;ve learned. Mostly working with Golang.\n","date":"18 January 2024","permalink":"/","section":"Kiet's blog","summary":"Hi üëã, I\u0026rsquo;m Kiet! This site is meant for me to document the things that I\u0026rsquo;ve learned. Mostly working with Golang.","title":"Kiet's blog"},{"content":"Explore the blog by topic.\n","date":"18 January 2024","permalink":"/tags/","section":"Tags","summary":"Explore the blog by topic.","title":"Tags"},{"content":"Articles that I write in my spare time.\n","date":"13 June 2022","permalink":"/posts/","section":"Blog","summary":"Articles that I write in my spare time.","title":"Blog"},{"content":"Hi, I\u0026rsquo;m Kiet üëã # I\u0026rsquo;m an aspiring software engineer who works in the back-end. I recently graduated from the Sepuluh Nopember Institute of Technology with a bachelor\u0026rsquo;s degree in Electrical-Engineering (EE). However, I\u0026rsquo;ve decided to pursue a slightly different career path: software engineering.\nPersonally, working in EE; dealing with PLCs, Motors, electrical diagrams, and other technical work wasn\u0026rsquo;t as enjoyable as programming software. The feeling I get seeing my projects come to life (albeit in a screen) is very enjoyable to me.\nMaybe it\u0026rsquo;s the fact that software documentation is more readily available than in EE. I remember spending a whole week reading the manual book to a Omron synchronous motor, and still not understanding a single thing. Whereas with the GCP or Golang docs, it would take much less time to understand since I can look up what other people have said using Google.\nThat\u0026rsquo;s why I want to become a software engineer. Hopefully a good one üòÅ.\n","date":"1 January 0001","permalink":"/about/","section":"Kiet's blog","summary":"Hi, I\u0026rsquo;m Kiet üëã # I\u0026rsquo;m an aspiring software engineer who works in the back-end. I recently graduated from the Sepuluh Nopember Institute of Technology with a bachelor\u0026rsquo;s degree in Electrical-Engineering (EE).","title":"About Me"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"This section contains some of my projects and certificates. Other exercises/projects are located in my github.\nü•ù Kiwish # Kiwish is an e-commerce platform. (WORK IN PROGRESS)\nRepo | Slideshow\nüîé True Sight # Tech Stack:\rGoogle Cloud Flask Kotlin Tensorflow True Sight is a news credibility checker platform that uses Natural Language Processing (NLP) to validate news submitted by users. App was available on Android using an API deployed on Google Cloud Run. I was in charge of designing the Google Cloud infrastructure. Created as the final project of the Bangkit Academy 2022 program with five other teammates.\nRepo | Slideshow\nüëî Clothera # Clothera is a simple CLI app for a Clothing store. Made purely with Golang and MySQL. Created for the Hacktiv8 bootcamp program with two of my friends.\nRepo | Slideshow\nüè¨ Hotel 626 # A hotel API mini-project made in around 24 hours. Created with Golang, PostgreSQL, GORM, and Echo. Includes a Xendit payment gateway and email notifications. Made for the Hacktiv8 bootcamp program.\nRepo\n‚öôÔ∏è DC Motor Speed Control with EKF \u0026amp; PI-PSO # A program to estimate and control the speed of a non-linear DC Motor without using speed sensors, only electrical sensors. The estimation was done using the Extended Kalman Filter (EKF) while the motor was controlled by a PI controller, tuned using the Particle Swarm Optimization (PSO) algorithm. The program was made using MATLAB scripts and Simulink. Created as my final project in university.\nRepo | Slideshow | Article\nüìú Certificates # ‚òÅÔ∏è Google Cloud Associate Cloud Engineer # An Associate Cloud Engineer deploys applications, monitors operations, and manages enterprise solutions. This individual is able to use Google Cloud Console and the command-line interface to perform common platform-based tasks to maintain one or more deployed solutions that leverage Google-managed or self-managed services on Google Cloud.\nLink: 5bce81b8cabf428aab3976f6247c4cb7\nüìö TOEFL iBT # The TOEFL iBT¬Æ test measures the ability to use and understand academic English. This certification is an asset for international mobility in over 160 countries. This test is a world reference. More than 35 million people worldwide have attested to their English language proficiency by taking the TOEFL iBT test. The test assesses written and oral comprehension and expression skills in an academic context from intermediate to advanced levels.\nFull certificate provided by request.\n","date":"1 January 0001","permalink":"/projects/","section":"Projects","summary":"This section contains some of my projects and certificates. Other exercises/projects are located in my github.\nü•ù Kiwish # Kiwish is an e-commerce platform. (WORK IN PROGRESS)\nRepo | Slideshow","title":"Projects"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]